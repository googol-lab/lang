<html>
<head><title>まるごとJavaScriptÈ</title></head>
<body>
<script type="text/javascript">
// Q1. returnの後に暗黙の;が入る
function foo(x) {
    return 
      x*80;
}
//alert(foo(1)); // undefined

// Q2. 式の途中なら入らない
function foo2(x) {
    return x
      +80;
}
//alert(foo2(1)); // 81

// Q3. ==演算子の方が優先
//alert(3 & 5 == 1); // 0

// Q4. ||と&&は真偽値を返すわけではない
//alert(8 == 10); // false
//alert(8 != 10); // true
//alert(8 || 10); // 8
//alert(8 && 10); // 10

// Q5. 最初のcaseにマッチしたあと間の式を全部実行
var x = 1;
switch (x) {
case x++:
  x = 1;
case x++:
  x--;
case x++:
//  alert(x); // 0
}

// Q6.文字列に+だと右オペランドにtoString,
//    *だと自分にvalueOf.
//alert("30" + 1); // 301
//alert("30" * 1); // 30
//alert("30" + 2); // 302
//alert("30" * 2); // 60

// Q7.
var x2 = new Object();
x2.foo getter = function () {
                         return 30;  }
//alert(x.foo); //firefox -> undefined
delete x.foo;
//alert(x.foo); //firefox -> undefined

// Q8. ===演算子では、両オペランドの型が違う時点でfalse
//alert('8' == 8); // true
//alert('8' === 8); // false
//alert('8' != 8); // false
//alert('8' !== 8); // true

// Q9. >>>だと符号ビットが拡張される
//alert(0x80000000 >> 1); // -2**30
//alert(0x80000000 >>> 1); // 2**30
//alert(-1 >> 1); // -1
//alert(-1 >>> 1); // 2**31-1

// Q10. 
var a = 10 / 3;
//alert(a); // 3.333…5
a *= 3
//alert(a); // 10

// Q11.
function false_check(x) {
    if (x) {
        alert('true');
    } else {
        alert('false');
    }
}

false_check(false); // false
false_check(0); // false
false_check(Number(0)); // false
false_check(new Number(0)); // true

var x3;
false_check(x3); // false
false_check(Boolean(false)); // false
false_check(new Boolean(false)); // true
false_check(Boolean(new
    Boolean(false))); // true
</script>
</body>
</html>
