(defun map0-n (fn n)
  (mapa-b fn 0 n))

(defun map1-n (fn n)
  (mapa-b fn 1 n))

(defun mapa-b (fn a b &optional (step 1))
  (do ((i a (+ i step))
       (result nil))
      ((> i b) (nreverse result))
    (push (funcall fn i) result)))

(defmacro our-with-gensyms (syms &body body)
  `(let ,(mapcar #'(lambda (s) `(,s (gensym)))
		 syms)
     ,@body))

(defmacro do-tuples/o (params source &body body)
  (if params
      (let ((src (gensym)))
	`(prog ((,src ,source))
	       (mapc #'(lambda ,params ,@body)
		     ,@(map0-n #'(lambda (n)
				   `(nthcdr ,n ,src))
			       (1- (length params))))))))

(defmacro do-tuples/c (params source &body body)
  (if params
      (our-with-gensyms 
       (src rest bodfn)
       (let ((len (length params)))
	 `(let ((,src ,source))
	    (when (nthcdr ,(1- len) ,src)
	      (labels ((,bodfn ,params ,@body))
		(do ((,rest ,src (cdr ,rest)))
		    ((not (nthcdr ,(1- len) ,rest))
		     ,@(mapcar #'(lambda (args)
				   `(,bodfn ,@args))
			       (dt-args len rest src))
		     nil)
		  (,bodfn ,@(map1-n #'(lambda (n)
					`(nth ,(1- n)
					      ,rest))
				    len))))))))))

(defun dt-args (len rest src)
  (map0-n #'(lambda (m)
	      (map1-n #'(lambda (n)
			  (let ((x (+ m n)))
			    (if (>= x len)
				`(nth ,(- x len) ,src)
			      `(nth ,(1- x) ,rest))))
		      len))
	  (- len 2)))
